\section{Introducci'on}
Lo primero que se pens'o fue en como dise'nar e implementar los dos tipos de 'arboles propuestos en el enunciado. La idea fue utilizar el interval tree ('arbol de intervalos) manteniendo el equilibrio de sus nodos mediante el red-black tree ('arbol rojo-negro) para obtener una complejidad eficiente, a'un en el peor caso. 

El red-black se dise'no sobre punteros. Cada 'arbol apunta a dos sub'arboles. En realidad la informaci'on se encuentra sobre nodos, pero solamente para mantenerla de forma m'as sencilla. Los algoritmos se basaron en los dados en clase, realizando las debidas rotaciones cuando, durante cierta inserci'on, se requiera para mantener el invariante de la estructura.

Para la elaboracion del Interval, primero se buscaron datos del mismo para complementar los entregados en el apunte dado por la catedra. Luego de revisar varios papers, se decidio seguir por la implementacion del pseudo-codigo suministrado por la Wikipedia, previa comparacion con los demas.

El arbol de intervalos es una estructura ordenada de datos que contiene intervalos. Sirve, principalmente, para poder encontrar, en una lista de intervalos, aquellos que se solapan con un punto dado o con un rango dado.
Este tipo de arboles se utilizan por sobre, por ejemplo, los arboles binarios ordinarios, debido a que, en los ultimos, el costo de una consulta sobre el arbol es del orden de $O(n)$, y en un arbol de intervalos, el orden obtenido es de $O(log_2(n)+m$ (Se explica con mas detalle en la seccion "Calculos de complejidad).

Este arbol se implemento sobre un Arbol Red-Black, para que siempre quede balanceado, ante cada insercion en el mismo. Tambien se podria haber usado un arbol binario o un AVL, pero se prefirio el RB ya que su comportamiento ante la insercion es mas estable que el AVL.

El interval contiene los algoritmos correspondientes para la inserci'on y la b'usqueda de valores, pero en realidad la informaci'on est'a guardada en un red-black. En cada nodo del 'arbol tenemos guardadas 2 listas, con los mismos intervalos, pero ordenadas de diferente manera. Una lista est ordena de mayor a menor por el valor de inicio de cada intervalo. La otra lista esta ordena, tambi'en de mayor a menor, pero por el valor de fin de cada intervalo.
Con una sola lista no alcanza ya que dependiendo el caso, necesito buscar por el valor de inicio o por el valor de fin.

Se procedio a implementar la estructura de la siguiente forma:

Para la creacion, el articulo sugiere tomar el rango total de los intervalos y dividirlo por la mitad, para tomar el elemento medio como pivot de la primera iteracion. Una vez hecho esto, se prodece a dividir la lista de intervalos en 3: aquellos que estan completamente a la izquierda del pivot, aquellos que lo contienen y por ultimo, aquellos que estan posterior al mismo. Una vez hecho esto, se inserta un nodo con el pivot como clave y como dato la lista generada que contiene a ese punto, pero esta ultima aparece en dos oportunidades. La primera, ordenando a los intervalos segun su punto de inicio, y la segunda, ordenandolos segun su punto de fin. Luego, se procede a realizar el algoritmo, pero ya con las dos listas restantes.

Por ejemplo:
Tengo los intervalos $[1,2]$,$[2,4]$,$[5,6]$ y $[2,3]$. Lo primero que hago es calcular el rango de los intervalos, que se hace tomando el minimo comienzo y el maximo final. En este caso, el rango me da $[1,6]$. Para tomar el pivot, tomo el punto medio de ese rango, o sea, el 3, redondeando para abajo. Ahora, tomo los intervalos y genero las listas izq, der y centro, explicadas en el parrafo anterior. La lista izq me quedaria: $[1,2]$. La der me quedaria: $[5,6]$ y la centro, $[2,4]$ y $[2,3]$.
Ahora, creo el nodo a insertar, poniendo al pivot como clave y a la lista centro dos veces, la primera ordenada por inicio (en este caso seria $[$[2,4]$,$[2,3]$]$) y la segunda por final (en este caso ($[2,3]$ y $[2,4]$)). Luego se agrega ese nodo al arbol, prosiguiendo a agregar a este tambien, los nodos generados a partir de llamar recursivamente a la funcion con las listas der e izq.

Al realizar una b'usqueda y tener la listas ordendas se reduce la cantidad de operaciones para obtener los intervalos deseados(los que contienen al punto dado) ya que en caso de recorrer y tener que devolver una cantidad de intervalos menor a la total no me hace falta recorrerla hasta el final, sino que al ir comparando el valor de inicio o fin, seg'un corresponda, de cada intervalo y al encontrar un valor menor o mayor, tambien seg'un corresponda, puedo devolver los intervalos agregados hasta el momento a la soluci'on y salir de la busqueda sin necesidad de seguir recorriendo porque ya se que mas adelante no voy a encontrar ning'un intervalo que contenga al punto dado. 
Si la lista estar'ia desordenada si o si deber'ia recorrer todos los intervalos ya que en nin'un momento puedo predecir el valor de inicio o fin del intervalo siguiente.

El objetivo es dado un punto x encontrar todos los intervalos que contienen a ese punto. Para esto, la idea del algoritmo consiste en ir comparando el valor x buscado con la clave de la raíz del 'arbol: 
\begin{itemize}
\item Si el valor de la clave es menor al de x agrego a la solucion los intervalos  del nodo que terminan despu'es de x utilizando la lista ordenada de mayor a menor por el valor fin. Utilizo esta lista porque ya se que todos los intervalos del nodo arrancan antes de x y al estar ordenada tendr'e que hacer k+1 comparaciones (o hasta la cantidad de intervalos) para obtener los k intervalos que contienen a ese punto. Luego de agregar los intervalos, si la rama derecha no es nula continuo con el algoritmo, tomando como el subarbol izquierdo ya que del lado izquierdo estan los intervalos que que finalizan despues del valor de la raiz y x es mayor a la raiz. Si es nula salgo.
\item Si el valor de la clave es mayor al de x agrego a la solucion los intervalos del nodo que empiezan antes de x utilizando la lista ordenada de mayor a menor por el valor inicio. Utilizo esta lista porque ya se que todos los intervalos del nodo terminan después de x, y al igual que en el otro caso, al estar ordenada tendr'e que hacer k+1 comparaciones (o hasta la cantidad de intervalos) para obtener los k intervalos que contienen a ese punto. Luego de agregar los intervalos, si la rama izquierda no es nula continuo con el algoritmo, tomando el subárbol derecho ya que del lado derecho estan los intervalos que empiezan antes del valor de la raiz y x es menor al valor de la raiz. Si es nula salgo.
\item Si el valor buscado es igual al de la clave, agrego a la solucion todos los intervalos del valor del nodo y si la rama izquierda no es nula continúo con el algoritmo, tomando el subarbol izquierdo. Si es nula salgo.
\end{itemize}

El programa principal mantiene dos 'arboles, cargando en uno la informaci'on horizontal (el intervalo $[x_i,x_f]$) y en el otro la vertical (el intervalo $[y_i,y_f]$) de cada im'agen. A la hora de realizar la consulta de un punto $p = (p_x,p_y)$, se busca el valor $p_x$ en el 'arbol de intervalos horizontales y el $p_y$, en el de verticales. Cada b'usqueda devolver'a una lista de intervalos a los cu'ales pertenece la respectiva componente de $p$. Notar que, para que una im'agen sea considerada como resultado, deber'a suceder que $p$ pertenezca a cada intervalo. Es decir, ambos intervalos de 'esta deber'an estar en las listas devueltas por el interval.

El primer algoritmo pensado para armar la lista de im'agenes fue el de armar una lista con las im'agenes que tienen los intervalos (horizontales) donde est'aba $p_x$. Luego 'esta lista se la filtrar'ia con los intervalos (verticales) donde estaba $p_y$, obteni'endose la lista de im'agenes deseadas. Como en el peor caso se deber'ia recorrer toda la lista de im'agenes para cada intervalo horizontal (se supone que la cantidad de ellas es $n$), la complejidad de 'este algoritmo ser'ia O($nk_x+k_xk_y$), donde $k_x$ es la cantidad de intervalos horizontales satisfactorios y $k_y$ la de intervalos verticales satisfactorios\footnote{Notar que 'estas cantidades podr'ian ser $n$ en el peor de los casos.}.

Una segunda idea fue de asignar un valor de identificaci'on a cada intervalo (llamado $id$) de manera que permita ubicar sencillamente a cual im'agen pertenece cada intervalo. Cuando se realiza la divisi'on de una im'agen en sus dos intervalos, 'estos recibir'an el mismo id, y ser'a la posici'on de la im'agen actual en la lista im'agenes de entrada. De 'esta forma, al tener ambas listas solamente resta comparar para cada elemento de una lista si el mismo id se encuenta en la otra. De as'i serlo, se agrega la im'agen a la lista de resultados (lo cual se hace en tiempo constante por ya tener la posici'on en la lista de la misma). Por lo tanto el algoritmo ser'ia O($k_xk_y$). Se puede ver que, como en el peor caso $k_x = k_y = n$, las complejidades de ambos algoritmos ser'ian iguales (cuadr'atica en funci'on de la cantidad de im'agenes) pero no nos quedamos del todo satisfechos. Lo implementamos y, cuando tuvimos los gr'aficos listos, vimos que 'este algotimo era un gran cuello de botella. La cantidad de operaciones para una consulta aumentaba considerablemente y hasta terminaba siendo peor que por fuerza bruta. Por lo tanto, nos pusimos a pensar otra alternativa.

La tercer y 'ultima opci'on consisti'o en agregar otro tipo de informaci'on adicional a las clases ya existentes. Al intervalo se le agrego una referencia a su \emph{padre} (es decir, a la imagen que contenia 'ese inervalo), y a la im'agen se le agregaron dos bits que marcan si fueron seleccionados en $x$ e $y$. La idea del algoritmo es recorrer ambas listas de intervalos en donde se generan las intersecciones e ir marcando a sus padres el correspondiente bit. Luego se realiza una pasada por la lista de im'agenes en busca de aquellas donde est'en tildados en los 2 bits. 'Estas son agregadas a la lista de resultados. Notar que, a su vez, mientras se recorren las im'agenes se van destildando los bits para que la estructura pueda volver a ser utilizada en la pr'oxima consulta. Como en el peor caso la cantidad de intervalos intersecados es $n$, la complejidad del algoritmo ser'ia O($3n$) = O($n$). Dado que es parecida a la del resto de los algoritmos utilizados en la b'usqueda, se lo termin'o elijiendo \underline{en un principio}. Pero ocurr'ia una contradicci'on de base: la complejidad del algoritmo de fuerza bruta es tambi'en lineal en funci'on de la cantidad de im'agenes (ya que debe ir comparando una por una buscando donde los inervalos contengan al punto) y nuestro algoritmo terminar'ia teniendo una complejidad $\Omega(n)$. Y para eso podr'iamos haber implementado 'este directamente que, total, es m'as sencillo. Por lo tanto se ide'o una especie de \emph{poda} de casos que no val'ian la pensa revisar, en el algoritmo que ya ten'iamos.

'Esta fue pensada haciendo que en la primer pasada, en lugar de marcar en x las im'agenes cullos intervalos horizontales se intersectaban al punto, se agregaron las im'agenes padre a una lista provisoria. Luego se marcaron normalmente los que intersectaban sobre y. Notar que en la lista provisoria hay una referencia a las im'agenes, por lo que los 'ultimos cambios influyeron sobre los que ya se encontraban all'i. Ahora, en lugar de revisar la lista completa de im'agenes s'olo se debe revisar la provisoria buscando en donde existe la marca en y, y 'estos son agregados. Luego se deber'a hacer un recorrido por las intersecciones en y para volver a resetear la marca de todos los padres que fueron alterados (si 'esto se hace en el bucle final como en el algoritmo anterior, podr'ian quedar algunas im'agenes que fueron marcadas en y sin resetear, porque 'estas podr'ian no haber sido agregadas a la lista provisoria de las marcas en x). Notar que en el peor caso (aquel donde todas las im'agenes intersectan horizontalmente con el punto) la complejidad sigue siendo la misma: $O(n)$, pero en caso promedio 'este valor es dif'icilmente alcanzado\footnote{Para m'as informaci'on, dirigirse a la secci'on de resultados.} , con lo que nos quedamos tranquilos que la implementaci'on de los 'arboles no fue en vano.

Notar que de 'esta forma las clases Intervalo e Imagen terminan teniendo cierto sabor a \emph{ad-hoc}, ya que se les agregan valores que carecen de sentido fuera del contexto que debe tener (el representar un intervalo como estructura matem'atica y una im'agen como una fotograf'ia). Igualmente fue preferida ya que
\begin{itemize}
\item Mejoraba notablemente la complejidad del algoritmo.
\item No nos pusimos en una posici'on tan \emph{purista}.
\end{itemize}
