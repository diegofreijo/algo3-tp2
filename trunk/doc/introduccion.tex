\section{Introducci'on}
Lo primero que se pens'o fue en como dise'nar e implementar los dos tipos de 'arboles propuestos en el enunciado. La idea fue utilizar el interval tree ('arbol de intervalos) manteniendo el equilibrio de sus nodos mediante el red-black tree ('arbol rojo-negro) para obtener una complejidad eficiente, a'un en el peor caso. 

El red-black se dise'no sobre punteros. Cada 'arbol apunta a dos sub'arboles. En realidad la informaci'on se encuentra sobre nodos, pero solamente para mantenerla de forma m'as sencilla. Los algoritmos se basaron en los dados en clase, realizando las debidas rotaciones cuando, durante cierta inserci'on, se requiera para mantener el invariante de la estructura.

El interval contiene los algoritmos correspondientes para la inserci'on y la b'usqueda de valores, pero en realidad la informaci'on est'a guardad en un red-black. ACA HAY QUE CONTAR SOBRE QUE HACE EN LA INSERCI'ON Y LA BUSQUEDA.

El programa principal mantiene dos 'arboles, cargando en uno la informaci'on horizontal (el intervalo $[x_i,x_f]$) y en el otro la vertical (el intervalo $[y_i,y_f]$) de cada im'agen. A la hora de realizar la consulta de un punto $p = (p_x,p_y)$, se busca el valor $p_x$ en el 'arbol de intervalos horizontales y el $p_y$, en el de verticales. Cada b'usqueda devolver'a una lista de intervalos a los cu'ales pertenece la respectiva componente de $p$. Notar que, para que una im'agen sea considerada como resultado, deber'a suceder que $p$ pertenezca a cada intervalo. Es decir, ambos intervalos de 'esta deber'an estar en las listas devueltas por el interval.

El primer algoritmo pensado para armar la lista de im'agenes fue el de armar una lista con las im'agenes que tienen los intervalos (horizontales) donde est'aba $p_x$. Luego 'esta lista se la filtrar'ia con los intervalos (verticales) donde estaba $p_y$, obteni'endose la lista de im'agenes deseadas. Como en el peor caso se deber'ia recorrer toda la lista de im'agenes para cada intervalo horizontal (se supone que la cantidad de ellas es $n$), la complejidad de 'este algoritmo ser'ia O($nk_x+k_xk_y$), donde $k_x$ es la cantidad de intervalos horizontales satisfactorios y $k_y$ la de intervalos verticales satisfactorios\footnote{Notar que 'estas cantidades podr'ian ser $n$ en el peor de los casos.}.

Una segunda idea fue de asignar un valor de identificaci'on a cada intervalo (llamado $id$) de manera que permita ubicar sencillamente a cual im'agen pertenece cada intervalo. Cuando se realiza la divisi'on de una im'agen en sus dos intervalos, 'estos recibir'an el mismo id, y ser'a la posici'on de la im'agen actual en la lista im'agenes de entrada. De 'esta forma, al tener ambas listas solamente resta comparar para cada elemento de una lista si el mismo id se encuenta en la otra. De as'i serlo, se agrega la im'agen a la lista de resultados (lo cual se hace en tiempo constante por ya tener la posici'on en la lista de la misma). Por lo tanto el algoritmo ser'ia O($k_xk_y$). Se puede ver que, como en el peor caso $k_x = k_y = n$, las complejidades de ambos algoritmos ser'ian iguales (cuadr'atica en funci'on de la cantidad de im'agenes) pero como consideramos que la cantidad de operaciones en la pra'ctica es menor, la tomamos como m'as \emph{eficiente}.

Notar que de 'esta forma la clase Intervalo termina teniendo cierto sabor a \emph{ad-hoc}, ya que se le agrega un n'umero identificador que carece de sentido fuera del contexto que debe tener (el representar un intervalo como estructura matem'atica). Igualmente fue preferida ya que
\begin{itemize}
\item Mejoraba la complejidad del algoritmo.
\item No nos pusimos en una posici'on tan \emph{purista}.
\end{itemize}
