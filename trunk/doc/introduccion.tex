\section{Introducci'on}
Lo primero que se pens'o fue en como dise'nar e implementar los dos tipos de 'arboles propuestos en el enunciado. La idea fue utilizar el interval tree ('arbol de intervalos) manteniendo el equilibrio de sus nodos mediante el red-black tree ('arbol rojo-negro) para obtener una complejidad eficiente, a'un en el peor caso. 

El red-black se dise'no sobre punteros. Cada 'arbol apunta a dos sub'arboles. En realidad la informaci'on se encuentra sobre nodos, pero solamente para mantenerla de forma m'as sencilla. Los algoritmos se basaron en los dados en clase, realizando las debidas rotaciones cuando, durante cierta inserci'on, se requiera para mantener el invariante de la estructura.

El interval contiene los algoritmos correspondientes para la inserci'on y la b'usqueda de valores, pero en realidad la informaci'on est'a guardada en un red-black. En cada nodo del 'arbol tenemos guardadas 2 listas, con los mismos intervalos, pero ordenadas de diferente manera. Una lista est ordena de mayor a menor por el valor de inicio de cada intervalo. La otra lista esta ordena, tambi'en de mayor a menor, pero por el valor de fin de cada intervalo.
Con una sola lista no alcanza ya que dependiendo el caso, necesito buscar por el valor de inicio o por el valor de fin.

Al realizar una b'usqueda y tener la listas ordendas se reduce la cantidad de operaciones para obtener los intervalos deseados(los que contienen al punto dado) ya que en caso de recorrer y tener que devolver una cantidad de intervalos menor a la total no me hace falta recorrerla hasta el final, sino que al ir comparando el valor de inicio o fin, seg'un corresponda, de cada intervalo y al encontrar un valor menor o mayor, tambien seg'un corresponda, puedo devolver los intervalos agregados hasta el momento a la soluci'on y salir de la busqueda sin necesidad de seguir recorriendo porque ya se que mas adelante no voy a encontrar ning'un intervalo que contenga al punto dado. 
Si la lista estar'ia desordenada si o si deber'ia recorrer todos los intervalos ya que en nin'un momento puedo predecir el valor de inicio o fin del intervalo siguiente.

El objetivo es dado un punto x encontrar todos los intervalos que contienen a ese punto. Para esto, la idea del algoritmo consiste en ir comparando el valor x buscado con la clave de la raíz del 'arbol: 
\begin{itemize}
\item Si el valor de la clave es menor al de x agrego a la solucion los intervalos  del nodo que terminan despu'es de x utilizando la lista ordenada de mayor a menor por el valor fin. Utilizo esta lista porque ya se que todos los intervalos del nodo arrancan antes de x y al estar ordenada tendr'e que hacer k+1 comparaciones (o hasta la cantidad de intervalos) para obtener los k intervalos que contienen a ese punto. Luego de agregar los intervalos, si la rama derecha no es nula continuo con el algoritmo, tomando como el subarbol izquierdo ya que del lado izquierdo estan los intervalos que que finalizan despues del valor de la raiz y x es mayor a la raiz. Si es nula salgo.
\item Si el valor de la clave es mayor al de x agrego a la solucion los intervalos del nodo que empiezan antes de x utilizando la lista ordenada de mayor a menor por el valor inicio. Utilizo esta lista porque ya se que todos los intervalos del nodo terminan después de x, y al igual que en el otro caso, al estar ordenada tendr'e que hacer k+1 comparaciones (o hasta la cantidad de intervalos) para obtener los k intervalos que contienen a ese punto. Luego de agregar los intervalos, si la rama izquierda no es nula continuo con el algoritmo, tomando el subárbol derecho ya que del lado derecho estan los intervalos que empiezan antes del valor de la raiz y x es menor al valor de la raiz. Si es nula salgo.
\item Si el valor buscado es igual al de la clave, agrego a la solucion todos los intervalos del valor del nodo y si la rama izquierda no es nula continúo con el algoritmo, tomando el subarbol izquierdo. Si es nula salgo.
\end{itemize}

El programa principal mantiene dos 'arboles, cargando en uno la informaci'on horizontal (el intervalo $[x_i,x_f]$) y en el otro la vertical (el intervalo $[y_i,y_f]$) de cada im'agen. A la hora de realizar la consulta de un punto $p = (p_x,p_y)$, se busca el valor $p_x$ en el 'arbol de intervalos horizontales y el $p_y$, en el de verticales. Cada b'usqueda devolver'a una lista de intervalos a los cu'ales pertenece la respectiva componente de $p$. Notar que, para que una im'agen sea considerada como resultado, deber'a suceder que $p$ pertenezca a cada intervalo. Es decir, ambos intervalos de 'esta deber'an estar en las listas devueltas por el interval.

El primer algoritmo pensado para armar la lista de im'agenes fue el de armar una lista con las im'agenes que tienen los intervalos (horizontales) donde est'aba $p_x$. Luego 'esta lista se la filtrar'ia con los intervalos (verticales) donde estaba $p_y$, obteni'endose la lista de im'agenes deseadas. Como en el peor caso se deber'ia recorrer toda la lista de im'agenes para cada intervalo horizontal (se supone que la cantidad de ellas es $n$), la complejidad de 'este algoritmo ser'ia O($nk_x+k_xk_y$), donde $k_x$ es la cantidad de intervalos horizontales satisfactorios y $k_y$ la de intervalos verticales satisfactorios\footnote{Notar que 'estas cantidades podr'ian ser $n$ en el peor de los casos.}.

Una segunda idea fue de asignar un valor de identificaci'on a cada intervalo (llamado $id$) de manera que permita ubicar sencillamente a cual im'agen pertenece cada intervalo. Cuando se realiza la divisi'on de una im'agen en sus dos intervalos, 'estos recibir'an el mismo id, y ser'a la posici'on de la im'agen actual en la lista im'agenes de entrada. De 'esta forma, al tener ambas listas solamente resta comparar para cada elemento de una lista si el mismo id se encuenta en la otra. De as'i serlo, se agrega la im'agen a la lista de resultados (lo cual se hace en tiempo constante por ya tener la posici'on en la lista de la misma). Por lo tanto el algoritmo ser'ia O($k_xk_y$). Se puede ver que, como en el peor caso $k_x = k_y = n$, las complejidades de ambos algoritmos ser'ian iguales (cuadr'atica en funci'on de la cantidad de im'agenes) pero no nos quedamos del todo satisfechos. Lo implementamos y, cuando tuvimos los gr'aficos listos, vimos que 'este algotimo era un gran cuello de botella. La cantidad de operaciones para una consulta aumentaba considerablemente y hasta terminaba siendo peor que por fuerza bruta. Por lo tanto, nos pusimos a pensar otra alternativa.

La tercer y 'ultima opci'on consisti'o en agregar otro tipo de informaci'on adicional a las clases ya existentes. Al intervalo se le agrego una referencia a su \emph{padre} (es decir, a la imagen que contenia 'ese inervalo), y a la im'agen se le agregaron dos bits que marcan si fueron seleccionados en $x$ e $y$. La idea del algoritmo es recorrer ambas listas de intervalos en donde se generan las intersecciones e ir marcando a sus padres el correspondiente bit. Luego se realiza una pasada por la lista de im'agenes en busca de aquellas donde est'en tildados en los 2 bits. 'Estas son agregadas a la lista de resultados. Notar que, a su vez, mientras se recorren las im'agenes se van destildando los bits para que la estructura pueda volver a ser utilizada en la pr'oxima consulta. Como en el peor caso la cantidad de intervalos intersecados es $n$, la complejidad del algoritmo ser'ia O($3n$) = O($n$). Dado que es parecida a la del resto de los algoritmos utilizados en la b'usqueda, se lo termin'o elijiendo.

Notar que de 'esta forma las clases Intervalo e Imagen terminan teniendo cierto sabor a \emph{ad-hoc}, ya que se les agregan valores que carecen de sentido fuera del contexto que debe tener (el representar un intervalo como estructura matem'atica y una im'agen como una fotograf'ia). Igualmente fue preferida ya que
\begin{itemize}
\item Mejoraba notablemente la complejidad del algoritmo.
\item No nos pusimos en una posici'on tan \emph{purista}.
\end{itemize}
